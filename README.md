## Boost + conan.io + CMake example 

Why the dependency manager???

Because:
* It's hard to maintain, especially when the project goes large.
* I'm personally, prefer don't repeat myself (see [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)) and re-use binary whenever possible.

I try to use conan.io for this. 
* It quite easy to switch between Boost versions on any platform. 
* And even do this automatically on CI/CD servers.

Usage example

1. Intrusive way.

We inject generated by Conan settings into CMakeLists.txt by editing it (ref. to [include](https://github.com/snikulov/conan.examples/blob/master/boost.log.intrusive/CMakeLists.txt#L14) ).

```shell
$ cd boost.log.intrusive; mkdir build; cd build
$ conan install .. --build missing
$ cmake ..
$ cmake --build .
```
We all set.

2. Non-intrusive or less intrusive way.

We already have our CMakeLists.txt file with a lot of ```find_packages(...)``` in it.
How to tell CMake to use Conan's binary packages? 
Inject search paths using [CMAKE_TOOLCHAIN_FILE](https://cmake.org/cmake/help/latest/variable/CMAKE_TOOLCHAIN_FILE.html).

**NOTE:** 

I'm not sure if it correct, because I, sometimes, check for this variable to detect if I'm in cross-compilation mode.

To avoid TOOLCHAIN_FILE usage, a perhaps better way to provide conan_paths.cmake's variables through the command line.

for example 
* ```$ cmake .. -D<BOOST_ROOT>=<path to dependency> [-D...]``` etc.
* include conan_paths.cmake on top of your CMakeLists.txt (intrusive, but less changes in find_packages).

```shell
$ cd boost.log.nonintrusive; mkdir build; cd build
$ conan install .. --build missing
$ cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_paths.cmake
$ cmake --build .
```
We all set.
